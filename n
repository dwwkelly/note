#!/usr/bin/env python

__author__ = "Devin Kelly"
__email__ = "dwwkelly@gmail.com"
__version__ = 0.1
__todo__ = '''
-add ability to edit note/todo/contact
-add support for mongolab backups
-add support for dropbox/box backups
-test todo system
-add ability to change todo state
-make install command that copies template files to home
-import contacts from google - https://developers.google.com/google-apps/contacts/v3/
-implement Contact.importVCard
-add a verify command that checks IDs collection against other collections for consistency
-switch to a SQL database?
-make a note info command which shows note, tags and all other metadata
'''

__added_features__ = '''
-add ability to delete note/todo/contact
-add system for handling contact (email, phone, address, etc)
-complete encrpytion implementation
-fine tune search
-possibly rewrite code to take utilize inheritance
-when editing a note, should the timestamp be the original, the newest or a list of all edits?
'''

import subprocess
import argparse
import os
import sys
import time
import copy
import subprocess as SP
from pymongo import MongoClient
from abc import ABCMeta, abstractmethod

try:
   import gnupg
except ImportError:
   pass

try:
   import dropbox
except ImportError:
   pass


RS = "\033[0m"     # reset
HC = "\033[1m"     # hicolor
UL = "\033[4m"     # underline
INV = "\033[7m"    # invert foreground and background
FBLK = "\033[30m"
FRED = "\033[31m"
FGRN = "\033[32m"
FYEL = "\033[33m"
FBLE = "\033[34m"
FMAG = "\033[35m"
FCYN = "\033[36m"
FWHT = "\033[37m"
BBLK = "\033[40m"
BRED = "\033[41m"
BGRN = "\033[42m"
BYEL = "\033[43m"
BBLE = "\033[44m"
BMAG = "\033[45m"
BCYN = "\033[46m"
BWHT = "\033[47m"


def main():

   runner = Runner()
   runner.null()


class dbBaseClass:
   __metaclass__ = ABCMeta

   @abstractmethod
   def addItem(self, itemType, itemContents):
      pass

   @abstractmethod
   def getItem(self, itemID):
      pass

   @abstractmethod
   def searchForItem(self, searchInfo):
      pass

   @abstractmethod
   def deleteItem(self, itemID):
      pass

   @abstractmethod
   def getBackup(self):
      pass


class mongoDB(dbBaseClass):

   def __init__(self, dbName):
      """

      """
      self.dbName = dbName

      self.client = MongoClient()
      adminDB = self.client['admin']
      textSearchEnabled = adminDB.command({"getParameter": 1, "textSearchEnabled": 1})['textSearchEnabled']

      if not textSearchEnabled:
         adminDB.command({"setParameter": 1, "textSearchEnabled": "true"})

      self.noteDB = self.client[self.dbName]

      if self.noteDB.IDs.find({"currentMax": {"$exists": True}}).count() == 0:
         self.noteDB['IDs'].insert({"currentMax": 0})

      if self.noteDB.IDs.find({"unusedIDs": {"$exists": True}}).count() == 0:
         self.noteDB['IDs'].insert({"unusedIDs": []})

   def addItem(self, itemType, itemContents, itemID=None):
      """
         itemType really means the collection name or table name
      """
      collection = self.noteDB[itemType]
      Weights = {ii: 1 for ii in itemContents.keys()}
      if collection not in self.noteDB.collection_names():
         ##collection.create_index([(collection.name, "text"), ("tags", "text")], weights={"tags": 10, "noteText": 5})
         collection.create_index([(collection.name, "text"), ("tags", "text")], weights=Weights)

      if itemID is None:
         itemContents['timestamps'] = [time.time()]
         itemContents["ID"] = self.getNewID()
         collection.insert(itemContents)
      else:
         _id = collection.find_one({"ID": itemID})["_id"]
         timestamps = collection.find_one({"ID": itemID})["timestamps"]
         timestamps.append(time.time())
         itemContents["timestamps"] = timestamps
         itemContents["ID"] = itemID
         collection.update({"_id": _id}, itemContents)

      return

   def getNewID(self):
      """
         Get a new ID by either incrementing the currentMax ID or using an unusedID

      """
      idCollection = self.noteDB['IDs']
      unusedIDs = idCollection.find_one({"unusedIDs": {"$exists": True}})['unusedIDs']

      if not unusedIDs:
         ID = idCollection.find_one({"currentMax": {"$exists": True}})['currentMax'] + 1
         idCollection.update({"currentMax": ID - 1}, {"currentMax": ID})
      else:
         unusedIDs = idCollection.find_one({"unusedIDs": {"$exists": True}})['unusedIDs']
         ID = min(unusedIDs)
         unusedIDs.remove(ID)
         idCollection.update({"unusedIDs": {"$exists": True}},
                             {"$set": {"unusedIDs": unusedIDs}})

      return ID

   def getItem(self, itemID):
      """
         Given an ID return the note JSON object

         {u'noteText': u'note8', u'ID': 3.0, u'tags': [u'8'], u'timestamps': [1381719620.315899]}

      """
      collections = self.noteDB.collection_names()
      collections.remove(u'system.indexes')
      collections.remove(u'IDs')

      for coll in collections:
         note = self.noteDB[coll].find_one({"ID": itemID})
         if note is not None:
            break

      del note["_id"]
      return note

   def getItemType(self, itemID):
      """
         Given an itemID, return the "type" i.e. the collection it belongs to.
      """
      collections = self.noteDB.collection_names()
      collections.remove(u'system.indexes')
      collections.remove(u'IDs')

      for coll in collections:
         note = self.noteDB[coll].find_one({"ID": itemID})
         if note is not None:
            return coll

   def searchForItem(self, searchInfo, resultLimit=20):
      """
      Given a search term returns a list of results that match that term:

         [{u'score': 5.5, u'obj': {u'noteText': u'note8', u'ID': 3.0, u'timestamps': [1381719620.315899]}}]

      """

      # FIXME -- move search to DB class
      #projection = {"ID": 1, "noteText": 1, "timestamps": 1, "_id": 0}
      #searchResults = self.noteDB.command("text", "notes", search=searchInfo, project=projection, limit=resultLimit)

      searchResults = []

      colls = self.noteDB.collection_names()
      colls.remove(u'system.indexes')
      colls.remove(u'IDs')

      proj = {"_id": 0}
      for coll in colls:
         res = self.noteDB.command("text", coll, search=searchInfo, project=proj, limit=resultLimit)['results']
         searchResults.extend(res)

      return searchResults

   def deleteItem(self, itemID):
      """
         Deletes item with ID = itemID, takes care of IDs collection
      """
      collections = self.noteDB.collection_names()
      collections.remove(u'system.indexes')
      collections.remove(u'IDs')

      currentMax = self.noteDB["IDs"].find_one({"currentMax": {"$exists": True}})['currentMax']
      unusedIDs = self.noteDB['IDs'].find_one({"unusedIDs": {"$exists": True}})['unusedIDs']

      if (itemID > currentMax) or (itemID in unusedIDs):
         print("Item {0} does not exist".format(itemID))
         sys.exit(1)

      # Find document with ID
      for coll in collections:
         self.noteDB[coll].remove({"ID": itemID})

      if currentMax == itemID:
         self.noteDB['IDs'].update({"currentMax": currentMax}, {"currentMax": currentMax - 1})
      else:
         unusedIDs.append(itemID)
         self.noteDB['IDs'].update({"unusedIDs": {"$exists": True}}, {"unusedIDs": unusedIDs})

   def getBackup(self):

      return


def sqliteDB(dbBaseClass):

   def __init__(self):

      return

   def addItem(self, itemType, itemContents):

      return

   def getItem(self, itemID):

      return

   def searchForItem(self, searchInfo):

      return

   def deleteItem(self, itemID):

      return

   def getBackup(self):

      return


class NoteBaseClass(object):
   __metaclass__ = ABCMeta

   """ Virtual Methods """

   @abstractmethod
   def __init__(self, db):
      self.homeDir = os.path.expanduser('~')
      self.tmpNote = os.path.join(self.homeDir, '.note.TMP')
      self.editor = os.getenv('EDITOR')
      self.db = db
      return

   @abstractmethod
   def edit(self, ID):
      return

   @abstractmethod
   def printItem(self):
      return

   @abstractmethod
   def new(self):
      return

   @abstractmethod
   def search(self, searchTerm):
      return

   """ Concrete Methods """

   def delete(self, ID):
      """

      """
      try:
         ID = int(ID[0])
      except TypeError:
         pass

      self.db.deleteItem(ID)
      return

   def startEditor(self, startingLine=1):
      if self.editor == "/usr/bin/vim" or self.editor == '/usr/local/bin/vim':
         subprocess.call([self.editor, "+{0}".format(startingLine),
                          "-c", "startinsert", self.tmpNote])
      else:
         subprocess.call([self.editor, self.tmpNote])

   def printResults(self, results):
      # Not sure if I want this in a pager or not
      pager = False
      if pager:
         try:
            import pydoc
            pydoc.pager('\n'.join(results))
         except ImportError:
            print '\n'.join(results)
      else:
         print '\n'.join(results)

      return


class Note(NoteBaseClass):
   def __init__(self, db):
      """

      """
      super(Note, self).__init__(db)
      self.noteType = "notes"
      self.noteTemplate = "NOTE\n\n\n\nTAGS\n\n\n"
      self.noteEditTemplate = "NOTE\n\n{0}\n\nTAGS\n\n{1}\n"

   def processNote(self):

      try:
         with open(self.tmpNote) as fd:
            lines = fd.read()
      except IOError:
         print("Config file doesn't exist, exiting")
         sys.exit(-1)

      noteText = lines[lines.index('NOTE') + 4: lines.index('TAGS')]
      noteText = noteText.split('\n')
      noteText = filter(lambda x: x != '', noteText)
      noteText = map(lambda x: x.rstrip(), noteText)
      noteText = '\n'.join(noteText)
      self.noteText = noteText

      tags = lines[lines.index('TAGS') + 4: -1]
      tags = tags.split(',')
      tags = filter(lambda x: x != '', tags)
      tags = map(lambda x: x.rstrip(), tags)
      tags = map(lambda x: x.lstrip(), tags)
      self.tags = tags

   def edit(self, ID):
      """

      """
      ID = int(ID[0])
      origNote = self.db.getItem(ID)
      origNotetext = origNote['noteText']
      origTags = ','.join(origNote['tags'])

      editText = self.noteEditTemplate.format(origNotetext, origTags)
      self.tmpNote = os.path.join(self.homeDir, '.note.TMP')
      with open(self.tmpNote, 'w') as fd:
         fd.write(editText)

      self.startEditor(3)
      self.processNote()
      self.db.addItem(self.noteType, {"noteText": self.noteText, "tags": self.tags}, ID)

   def new(self, dummy=None):
      """

      """

      with open(self.tmpNote, 'w') as fd:
         fd.write(self.noteTemplate)
      self.startEditor(3)
      self.processNote()

      if self.noteText:
         self.db.addItem("notes", {"noteText": self.noteText, "tags": self.tags})

      return

   def search(self, searchTerm, resultLimit=20):
      """

      """
      results = []
      searchResults = self.db.searchForItem(searchTerm, resultLimit)
      for result in searchResults:
         noteText = result['obj']['noteText']
         ID = int(result['obj']['ID'])
         timestamps = result['obj']['timestamps']
         timestamp = time.localtime(max(timestamps))
         noteDate = time.strftime("%a, %b %d", timestamp)
         results.append( "{5}{6} {4}{2}{0}:{3} {1}".format(noteDate, noteText, FRED, RS, HC, FBLE, ID))

      self.printResults(results)

   def printItem(self, ID):
      result = self.db.getItem(ID)
      noteText = result['noteText']
      timestamps = result['timestamps']
      timestamp = time.localtime(max(timestamps))
      noteDate = time.strftime("%a, %b %d", timestamp)
      print "{5}{6} {4}{2}{0}:{3} {1}".format(noteDate, noteText, FRED, RS, HC, FBLE, ID)


class ToDo(NoteBaseClass):

   def __init__(self, db):
      super(ToDo, self).__init__(db)
      self.noteType = "todos"
      self.todoTemplate = "TODO\n\n\n\nDONE\n\n\n\nDATE - MM DD YY\n\n\n"
      self.todoEditTemplate = "TODO\n\n{0}\n\nDONE\n\n{1}\n\nDATE - MM DD YY\n\n\n"

   def edit(self, ID):
      return

   def new(self, dummy=None):
      self.tmpNote = os.path.join(self.homeDir, '.todo.TMP')
      with open(self.tmpNote, 'w') as fd:
         fd.write(self.todoTemplate)
      self.startEditor(2)
      self.processTodo()
      self.db.addItem(self.noteType, {"todoText": self.todoText, "done": self.done, "date": self.date})
      return

   def processTodo(self):
      try:
         with open(self.tmpNote) as fd:
            lines = fd.read()
      except IOError:
         print("Config file doesn't exist, exiting")
         sys.exit(-1)

      todoText = lines[lines.index('TODO') + 4: lines.index('DONE')]
      todoText = todoText.split('\n')
      todoText = filter(lambda x: x != '', todoText)
      todoText = map(lambda x: x.rstrip(), todoText)
      todoText = '\n'.join(todoText)
      self.todoText = todoText

      done = lines[lines.index('DONE') + 4: lines.index('DATE - MM DD YY')]
      doneText = done.split('\n')
      doneText = filter(lambda x: x != '', doneText)
      doneText = map(lambda x: x.rstrip(), doneText)
      doneText = '\n'.join(doneText)
      doneText = doneText.lower()
      if ('t' in doneText or 'true' in doneText or 'yes' in doneText) and \
         ('f' not in doneText or 'false' not in doneText or 'no' not in doneText):
         self.done = True
      else:
         self.done = False

      date = lines[lines.index('DATE - MM DD YY') + 15: -1]
      date = date.strip()
      self.date = date

   def search(self, searchTerm):

      return

   def showDone(self, dummy=None):
      return

   def showUndone(self, dummy=None):
      return

   def printItem(self, ID):
      result = self.db.getItem(ID)
      resultsStr = ""
      timestamps = result['timestamps']
      timestamp = time.localtime(max(timestamps))
      noteDate = time.strftime("%a, %b %d", timestamp)
      print "{5}{6} {4}{2}{0}:{3} {1}".format(noteDate, resultsStr, FRED, RS, HC, FBLE, ID)


class Contact(NoteBaseClass):

   def __init__(self, db):
      super(Contact, self).__init__(db)
      self.noteType = "contacts"
      self.contactTemplate = "NAME\n\n\n\nAFFILIATION\n\n\n\nEMAIL\n\n\n\nMOBILE PHONE\n\n\n\nHOME PHONE\n\n\n\nWORK PHONE\n\n\n\nADDRESS\n\n\n"
      self.contactEditTemplate = "NAME\n\n{0}\n\nAFFILIATION\n\n{1}\n\nEMAIL\n\n{2}\n\nMOBILE PHONE\n\n{3}\n\nHOME PHONE\n\n{4}\n\nWORK PHONE\n\n{5}\n\nADDRESS\n\n\n"
      self.keys = ["NAME", "AFFILIATION", "EMAIL", "MOBILE PHONE", "HOME PHONE", "WORK PHONE", "ADDRESS"]
      self.tmpNote = os.path.join(self.homeDir, '.contact.TMP')
      self.contactInfo = {}

   def edit(self, ID):

      ID = int(ID[0])
      origContact = self.db.getItem(ID)
      self.contactEditTemplate

      editText = self.contactEditTemplate.format(origContact['NAME'],
                                                 origContact['AFFILIATION'],
                                                 origContact['EMAIL'],
                                                 origContact['MOBILE PHONE'],
                                                 origContact['HOME PHONE'],
                                                 origContact['WORK PHONE'],
                                                 origContact['ADDRESS'])

      with open(self.tmpNote, 'w') as fd:
         fd.write(editText)

      self.startEditor(3)
      self.processContact()
      self.db.addItem(self.noteType, self.contactInfo, ID)
      return

   def new(self, dummy=None):
      with open(self.tmpNote, 'w') as fd:
         fd.write(self.contactTemplate)
      self.startEditor(3)
      self.processContact()
      self.db.addItem("contacts", self.contactInfo)

   def processContact(self):
      try:
         with open(self.tmpNote) as fd:
            lines = fd.read()
      except IOError:
         print("Config file doesn't exist, exiting")
         sys.exit(-1)

      keys = copy.deepcopy(self.keys)
      keys.reverse()

      for k in keys:
         self.contactInfo[k] = (lines.split(k)[-1]).strip()
         lines = " ".join(lines.split(k)[0:-1])

   def search(self, searchTerm, resultLimit=20):
      results = []
      searchResults = self.db.searchForItem(searchTerm, resultLimit)
      for result in searchResults:
         name = result['obj']['NAME']
         work_phone = result['obj']['WORK PHONE']
         affiliation = result['obj']['AFFILIATION']
         mobile_phone = result['obj']['MOBILE PHONE']
         address = result['obj']['ADDRESS']
         email = result['obj']['EMAIL']
         home_phone = result['obj']['HOME PHONE']

         order = [name, affiliation, email, mobile_phone, work_phone, home_phone, address]
         order = [ii for ii in order if ii]  # remove all the empty strings
         resultsStr = ", ".join(order)

         ID = int(result['obj']['ID'])
         timestamps = result['obj']['timestamps']
         timestamp = time.localtime(max(timestamps))
         noteDate = time.strftime("%a, %b %d", timestamp)
         results.append( "{5}{6} {4}{2}{0}:{3} {1}, {7}, {8}, {9}, {10}, {11}".format(noteDate, resultsStr, FRED, RS, HC, FBLE, ID ))

      self.printResults(results)

   def printItem(self, ID):
      result = self.db.getItem(ID)
      name = result['NAME']
      work_phone = result['WORK PHONE']
      affiliation = result['AFFILIATION']
      mobile_phone = result['MOBILE PHONE']
      address = result['ADDRESS']
      email = result['EMAIL']
      home_phone = result['HOME PHONE']

      order = [name, affiliation, email, mobile_phone, work_phone, home_phone, address]
      order = [ii for ii in order if ii]  # remove all the empty strings
      resultsStr = ", ".join(order)
      timestamps = result['timestamps']
      timestamp = time.localtime(max(timestamps))
      noteDate = time.strftime("%a, %b %d", timestamp)
      print "{5}{6} {4}{2}{0}:{3} {1}".format(noteDate, resultsStr, FRED, RS, HC, FBLE, ID)

   def importVCard(self):

      return


class Runner(object):

   def __init__(self):

      self.dbName = 'note'
      self.db = mongoDB(self.dbName)

      self.commands = ['backup', 'showUndone', 'showDone', 'todo', 'contact', 'edit', 'delete', 'search', 'add']
      note = Note(self.db)
      todo = ToDo(self.db)
      contact = Contact(self.db)
      self.itemTypes = {"notes": note, "todos": todo, "contacts": contact}

      self.commands = dict()
      self.commands['add'] = note.new
      self.commands['search'] = self.search
      self.commands['delete'] = note.delete
      self.commands['edit'] = note.edit

      self.commands['contact'] = contact.new
      self.commands['todo'] = todo.new
      self.commands['showDone'] = todo.showDone
      self.commands['showUndone'] = todo.showUndone
      self.commands['backup'] = self.backup

      self.parseOpts()

      if self.command in ['edit', 'delete', 'e', 'D']:
         itemType = self.db.getItemType(int(self.commandArgs[0]))
         self.commands['delete'] = self.itemTypes[itemType].delete
         self.commands['edit'] = self.itemTypes[itemType].edit

      # These are undocumented shortcuts
      self.commands['a'] = self.commands['add']
      self.commands['s'] = self.commands['search']
      self.commands['D'] = self.commands['delete']
      self.commands['e'] = self.commands['edit']

      self.commands['t'] = self.commands['todo']
      self.commands['d'] = self.commands['showDone']
      self.commands['u'] = self.commands['showUndone']
      self.commands['c'] = self.commands['contact']
      self.commands['b'] = self.commands['backup']

      self.commands[self.command](self.commandArgs)
      #try:
      #   self.commands[self.command](self.commandArgs)
      #except KeyError:
      #   print "{0} does not exist".format(self.command)
      #   sys.exit(0)

   def null(self):
      return

   def search(self, searchTerm):
      searchTerm = searchTerm[0]

      results = self.db.searchForItem(searchTerm)

      for item in results:
         ID = item['obj'][u"ID"]
         itemType = self.db.getItemType(ID)
         self.itemTypes[itemType].printItem(ID)

   def parseOpts(self):
      parser = argparse.ArgumentParser(description="note")

      defaultConfigPath = os.path.expanduser('~/.note.json')
      parser.add_argument('--configFile', type=str, help='Path to config file',
                          default=defaultConfigPath)

      commandHelp = 'note: eligible commands are: {0}'.format(', '.join(self.commands))
      parser.add_argument('command', metavar='cmd', type=str, nargs='+',
                          help=commandHelp)

      args = parser.parse_args()

      self.configFile = args.configFile
      self.command = args.command[0]

      self.commandArgs = args.command[1:]

      return

   def backup(self, dst):

      self.initGPG()

      if not dst:
         dst = '/tmp'
      else:
         dst = dst[0]

      backupZip = os.path.join(dst, 'note_backup.zip')
      backupGPG = os.path.join(dst, 'note_backup.gpg')

      with open(os.devnull) as devnull:
         SP.call(['mongodump', '--db', self.dbName, '--out', dst], stdout=devnull, stderr=devnull)
         SP.call(['zip', '-r', os.path.join(dst, backupZip), os.path.join(dst, self.dbName)], stdout=devnull, stderr=devnull)

      if self.key is not None:
         stream = open(backupZip, "rb")
         self.gpg.encrypt_file(stream, [self.key['fingerprint']], output=backupGPG)
         SP.call(['rm', '-rf', os.path.join(dst, 'note_backup.zip')])
         print "Encrypted Backup: {0}".format(backupGPG)
      else:
         print "Backup: {0}".format(backupZip)

      SP.call(['rm', '-rf', os.path.join(dst, self.dbName)])

      return

   def encrypt(self):

      return

   def initGPG(self):
      try:
         self.gpg = gnupg.GPG()
      except NameError:
         self.gpg = None
         self.key = None
         return

      private_keys = self.gpg.list_keys(True)
      usable_keys = []
      for key in private_keys:
         if time.time() < key['expires']:
            usable_keys.append(key)

      print "Select key:"
      counter = 0
      for key in usable_keys:
         print "[{0}] Fingerprint: {1}, Key Length: {2}, UIDs: {3}".format(counter, key['fingerprint'], key['length'], key['uids'])
         counter = counter + 1

      data = int(sys.stdin.readline())

      if data == 0:
         self.key = None
      else:
         self.key = usable_keys[data - 1]

      return

   def pushToDropbox(self):

      app_key = ''
      app_secret = ''
      code = ""

      flow = dropbox.client.DropboxOAuth2FlowNoRedirect(app_key, app_secret)

      access_token, user_id = flow.finish(code)
      client = dropbox.client.DropboxClient(access_token)

      f = open(self.mongoBackup)
      response = client.put_file('/note-backup.gpg', f)
      print "uploaded:", response


if __name__ == '__main__':
   main()
