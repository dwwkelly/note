#!/usr/bin/env python

__author__ = "Devin Kelly"
__email__ = "dwwkelly@gmail.com"
__version__ = 0.1
__todo__ = '''
-complete encrpytion implementation
-add support for mongolab backups
-add support for dropbox/box backups
-fine tune search
-test todo system
-add ability to edit note/todo/contact
-add ability to change todo state
-make install command that copies template files to home
-import contacts from google - https://developers.google.com/google-apps/contacts/v3/
-add a verify command that checks IDs collection against other collections for consistency
-switch to a SQL database?
'''

__added_features__ = '''
-add ability to delete note/todo/contact
-add system for handling contact (email, phone, address, etc)
'''

import subprocess
import shutil
import argparse
import os
import sys
import time
import subprocess as SP
from pymongo import MongoClient

try:
   import gnupg
except ImportError:
   pass

try:
   import dropbox
except ImportError:
   pass


RS = "\033[0m"     # reset
HC = "\033[1m"     # hicolor
UL = "\033[4m"     # underline
INV = "\033[7m"    # invert foreground and background
FBLK = "\033[30m"
FRED = "\033[31m"
FGRN = "\033[32m"
FYEL = "\033[33m"
FBLE = "\033[34m"
FMAG = "\033[35m"
FCYN = "\033[36m"
FWHT = "\033[37m"
BBLK = "\033[40m"
BRED = "\033[41m"
BGRN = "\033[42m"
BYEL = "\033[43m"
BBLE = "\033[44m"
BMAG = "\033[45m"
BCYN = "\033[46m"
BWHT = "\033[47m"


def main():

   note = Note()
   note.null()


class Note(object):

   def __init__(self):

      self.dbName = 'note'

      self.initDB()

      self.homeDir = os.path.expanduser('~')
      templateNoteName = '.noteTemplate'
      self.templateNote = os.path.join(self.homeDir, templateNoteName)
      templateContactName = '.contactTemplate'
      self.templateContact = os.path.join(self.homeDir, templateContactName)
      self.editor = os.getenv('EDITOR')
      self.tmpNote = None

      self.commands = dict()
      self.commands['add'] = self.newNote
      self.commands['search'] = self.search
      self.commands['todo'] = self.newTodo
      self.commands['backup'] = self.backup
      self.commands['contact'] = self.newContact
      self.commands['showDone'] = self.showDone
      self.commands['showUndone'] = self.showUndone
      self.commands['delete'] = self.delete
      self.commands['backup'] = self.backup

      self.parseOpts()

      # These are undocumented shortcuts
      self.commands['a'] = self.newNote
      self.commands['s'] = self.search
      self.commands['t'] = self.newTodo
      self.commands['b'] = self.backup
      self.commands['c'] = self.newContact
      self.commands['d'] = self.showDone
      self.commands['u'] = self.showUndone
      self.commands['D'] = self.delete
      self.commands['b'] = self.backup

      try:
         self.commands[self.command](self.commandArgs)
      except KeyError:
         print "{0} does not exist".format(self.command)
         sys.exit(0)

   def delete(self, ID):
      ID = int(ID[0])
      client = MongoClient()
      noteDB = client[self.dbName]

      # Find document with ID
      colls = ['notes', 'todo', 'contacts']
      for coll in colls:
         noteDB[coll].remove({"ID": ID})

      unusedIDs = noteDB['IDs'].find_one({"unusedIDs": {"$exists": True}})['unusedIDs']
      unusedIDs.append(ID)
      noteDB['IDs'].update({"unusedIDs": {"$exists": True}}, {"unusedIDs": unusedIDs})

      return

   def search(self, term, resultLimit=50):
      client = MongoClient()
      noteDB = client[self.dbName]

      projection = {"ID": 1, "noteText": 1, "timestamp": 1, "_id": 0}
      searchResults = noteDB.command("text", "notes", search=term[0], project=projection, limit=resultLimit)

      results = []
      for result in searchResults['results']:
         noteText = result['obj']['noteText']
         ID = int(result['obj']['ID'])
         timestamp = time.localtime(result['obj']['timestamp'])
         noteDate = time.strftime("%a, %b %d", timestamp)
         results.append( "{5}{6} {4}{2}{0}:{3} {1}".format(noteDate, noteText, FRED, RS, HC, FBLE, ID))

      self.printResults(results)

      return

   def showDone(self, null=None):
      client = MongoClient()
      noteDB = client[self.dbName]
      #projection = {"todo": 1, "done": 1, "_id": 0}
      searchResults = noteDB['todo'].find({"done": True})

      results = []
      for result in searchResults:
         text = result['todo']
         timestamp = time.localtime(result['timestamp'])
         date = time.strftime("%a, %b %d", timestamp)
         results.append( "{4}{2}{0}:{3} {1}".format(date, text, FRED, RS, HC))

      self.printResults(results)

      return

   def showUndone(self, null=None):
      client = MongoClient()
      noteDB = client[self.dbName]
      #projection = {"todo": 1, "done": 1, "_id": 0}
      searchResults = noteDB['todo'].find({"done": False})

      results = []
      for result in searchResults:
         text = result['todo']
         timestamp = time.localtime(result['timestamp'])
         date = time.strftime("%a, %b %d", timestamp)
         results.append( "{4}{2}{0}:{3} {1}".format(date, text, FRED, RS, HC))

      self.printResults(results)

      return

   def printResults(self, results):
      # Not sure if I want this in a pager or not
      pager = False
      if pager:
         try:
            import pydoc
            pydoc.pager('\n'.join(results))
         except ImportError:
            print '\n'.join(results)
      else:
         print '\n'.join(results)

      return

   def newTodo(self, null=None):
      self.tmpNote = os.path.join(self.homeDir, '.todo.TMP')
      self.tmpTodo = os.path.join(self.homeDir, '.todoTemplate')
      shutil.copyfile(self.tmpTodo, self.tmpNote)
      self.startEditor(2)
      self.processTodo()
      self.addTodoToDB()

   def processTodo(self):
      try:
         with open(self.tmpNote) as fd:
            lines = fd.read()
      except IOError:
         print("Config file doesn't exist, exiting")
         sys.exit(-1)

      todoText = lines[lines.index('TODO') + 4: lines.index('DONE')]
      todoText = todoText.split('\n')
      todoText = filter(lambda x: x != '', todoText)
      todoText = map(lambda x: x.rstrip(), todoText)
      todoText = '\n'.join(todoText)
      self.todoText = todoText

      done = lines[lines.index('DONE') + 4: lines.index('DATE')]
      doneText = done.split('\n')
      doneText = filter(lambda x: x != '', doneText)
      doneText = map(lambda x: x.rstrip(), doneText)
      doneText = '\n'.join(doneText)
      doneText = doneText.lower()
      if ('t' in doneText or 'true' in doneText) and ('f' not in doneText or 'false' not in doneText):
         self.done = True
      else:
         self.done = False

      date = lines[lines.index('DATE') + 4: -1]
      date = date.strip()
      self.date = date

      return

   def addTodoToDB(self):
      client = MongoClient()
      db = client['note']
      collection = db['todo']

      post = {"todo": self.todoText,
              "done": self.done,
              "timestamp": time.time()}
      collection.insert(post)

      return

   def null(self):
      return

   def initDB(self):
      client = MongoClient()
      adminDB = client['admin']
      textSearchEnabled = adminDB.command({"getParameter": 1, "textSearchEnabled": 1})['textSearchEnabled']

      if not textSearchEnabled:
         adminDB.command({"setParameter": 1, "textSearchEnabled": "true"})

      noteDB = client['note']
      if 'notes' not in noteDB.collection_names():
         noteDB.notes.create_index([("noteText", "text"), ("tags", "text")], weights={"tags": 10, "noteText": 5})

      if noteDB.IDs.find({"currentMax": {"$exists": True}}).count() == 0:
         noteDB['IDs'].insert({"currentMax": 0})

      if noteDB.IDs.find({"unusedIDs": {"$exists": True}}).count() == 0:
         noteDB['IDs'].insert({"unusedIDs": []})

   def newNote(self, null=""):
      self.tmpNote = os.path.join(self.homeDir, '.note.TMP')
      shutil.copyfile(self.templateNote, self.tmpNote)
      self.startEditor(3)
      self.processNote()
      self.addNoteToDB()

      return

   def processNote(self):

      try:
         with open(self.tmpNote) as fd:
            lines = fd.read()
      except IOError:
         print("Config file doesn't exist, exiting")
         sys.exit(-1)

      noteText = lines[lines.index('NOTE') + 4: lines.index('TAGS')]
      noteText = noteText.split('\n')
      noteText = filter(lambda x: x != '', noteText)
      noteText = map(lambda x: x.rstrip(), noteText)
      noteText = '\n'.join(noteText)
      self.noteText = noteText

      tags = lines[lines.index('TAGS') + 4: -1]
      tags = tags.split(',')
      tags = filter(lambda x: x != '', tags)
      tags = map(lambda x: x.rstrip(), tags)
      tags = map(lambda x: x.lstrip(), tags)
      self.tags = tags

      return

   def addNoteToDB(self):
      client = MongoClient()
      db = client['note']
      collection = db['notes']

      post = {"noteText": self.noteText,
              "tags": self.tags,
              "timestamp": time.time(),
              "ID": self.getID()}

      collection.insert(post)

   def newContact(self, null=None):
      self.tmpNote = os.path.join(self.homeDir, '.contact.TMP')
      shutil.copyfile(self.templateContact, self.tmpNote)
      self.startEditor(2)
      self.processContact()
      self.addContactToDB()

      return

   def processContact(self):

      with open(self.tmpNote) as fd:
         contactText = fd.read(8192)

      contactInfo = {}
      idx = []
      lines = contactText.split('\n')
      for i in range(len(lines)):
         if lines[i].isupper():
            idx.append(i)

      for i in range(len(idx)):
         start = idx[i] + 1
         try:
            end = idx[i + 1]
         except:
            end = len(lines) - 1
         key = lines[idx[i]].lower()
         info = lines[start:end]
         info = [x for x in info if x != '']
         if info:
            contactInfo[key] = '\n'.join(info)

      self.contactInfo = contactInfo

      return

   def getID(self):
      client = MongoClient()
      db = client['note']

      unusedIDs = db['IDs'].find_one({"unusedIDs": {"$exists": True}})['unusedIDs']

      if not unusedIDs:
         ID = db['IDs'].find_one({"currentMax": {"$exists": True}})['currentMax'] + 1
         db['IDs'].update({"currentMax": ID - 1}, {"currentMax": ID})
      else:
         unusedIDs = db['IDs'].find_one({"unusedIDs": {"$exists": True}})['unusedIDs']
         ID = min(unusedIDs)
         unusedIDs.remove(ID)
         db['IDs'].update({"unusedIDs": {"$exists": True}},
                          {"$set": {"unusedIDs": unusedIDs}})

      return ID

   def addContactToDB(self):
      client = MongoClient()
      db = client['note']
      collection = db['contacts']

      ID = self.getID()

      post = {"contact": self.contactInfo,
              "timestamp": time.time(),
              "ID": ID}

      collection.insert(post)

      return

   def startEditor(self, startingLine=1):
      if self.editor == "/usr/bin/vim" or self.editor == '/usr/local/bin/vim':
         subprocess.call([self.editor, "+{0}".format(startingLine),
                          "-c", "startinsert", self.tmpNote])
      else:
         subprocess.call([self.editor, self.tmpNote])

   def parseOpts(self):
      parser = argparse.ArgumentParser(description="note")

      defaultConfigPath = os.path.expanduser('~/.note.json')
      parser.add_argument('--configFile', type=str, help='Path to config file',
                          default=defaultConfigPath)

      commandHelp = 'note: eligible commands are: {0}'.format(', '.join(self.commands.keys()))
      parser.add_argument('command', metavar='cmd', type=str, nargs='+',
                          help=commandHelp)

      args = parser.parse_args()

      self.configFile = args.configFile
      self.command = args.command[0]

      self.commandArgs = args.command[1:]

      return

   def backup(self, dst):

      self.initGPG()

      if not dst:
         dst = '/tmp'
      else:
         dst = dst[0]

      backupZip = os.path.join(dst, 'note_backup.zip')
      backupGPG = os.path.join(dst, 'note_backup.gpg')

      with open(os.devnull) as devnull:
         SP.call(['mongodump', '--db', self.dbName, '--out', dst], stdout=devnull, stderr=devnull)
         SP.call(['zip', '-r', os.path.join(dst, backupZip), os.path.join(dst, self.dbName)], stdout=devnull, stderr=devnull)

      if self.key is not None:
         stream = open(backupZip, "rb")
         self.gpg.encrypt_file(stream, [self.key['fingerprint']], output=backupGPG)
         SP.call(['rm', '-rf', os.path.join(dst, 'note_backup.zip')])
         print "Encrypted Backup: {0}".format(backupGPG)
      else:
         print "Backup: {0}".format(backupZip)


      SP.call(['rm', '-rf', os.path.join(dst, self.dbName)])


      return

   def encrypt(self):

      return

   def initGPG(self):
      try:
         self.gpg = gnupg.GPG()
      except NameError:
         self.gpg = None
         self.key = None
         return

      private_keys = self.gpg.list_keys(True)
      usable_keys = []
      for key in private_keys:
         if time.time() < key['expires']:
            usable_keys.append(key)

      print "Select key:"
      counter = 0
      for key in usable_keys:
         print "[{0}] Fingerprint: {1}, Key Length: {2}, UIDs: {3}".format(counter, key['fingerprint'], key['length'], key['uids'])
         counter = counter + 1

      data = int(sys.stdin.readline())

      if data == 0:
         self.key = None
      else:
         self.key = usable_keys[data - 1]

      return

   def pushToDropbox(self):

      app_key = ''
      app_secret = ''
      code = ""

      flow = dropbox.client.DropboxOAuth2FlowNoRedirect(app_key, app_secret)

      access_token, user_id = flow.finish(code)
      client = dropbox.client.DropboxClient(access_token)

      f = open(self.mongoBackup)
      response = client.put_file('/note-backup.gpg', f)
      print "uploaded:", response


if __name__ == '__main__':
   main()
