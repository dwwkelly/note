#!/usr/bin/env python

__author__ = "Devin Kelly"
__email__ = "dwwkelly@gmail.com"
__version__ = 0.1
__todo__ = '''
-complete encrpytion implementation
-add support for mongolab backups
-add support for dropbox/box backups
-fine tune search
-test todo system
-add ability to edit note/todo/contact
-add ability to change todo state
-make install command that copies template files to home
-import contacts from google
-add a verify command that checks IDs collection against other collections for consistency
-switch to a SQL database?
'''

__added_features__ = '''
-add ability to delete note/todo/contact
-add system for handling contact (email, phone, address, etc)
'''

import subprocess
import shutil
import argparse
import os
import sys
import time
from pymongo import MongoClient

try:
   import gnupg
except ImportError:
   pass


RS = "\033[0m"     # reset
HC = "\033[1m"     # hicolor
UL = "\033[4m"     # underline
INV = "\033[7m"    # invert foreground and background
FBLK = "\033[30m"
FRED = "\033[31m"
FGRN = "\033[32m"
FYEL = "\033[33m"
FBLE = "\033[34m"
FMAG = "\033[35m"
FCYN = "\033[36m"
FWHT = "\033[37m"
BBLK = "\033[40m"
BRED = "\033[41m"
BGRN = "\033[42m"
BYEL = "\033[43m"
BBLE = "\033[44m"
BMAG = "\033[45m"
BCYN = "\033[46m"
BWHT = "\033[47m"


def main():

   note = Note()
   note.null()


class Note(object):

   def __init__(self):
      self.initDB()

      self.homeDir = os.path.expanduser('~')
      templateNoteName = '.noteTemplate'
      self.templateNote = os.path.join(self.homeDir, templateNoteName)
      templateContactName = '.contactTemplate'
      self.templateContact = os.path.join(self.homeDir, templateContactName)
      self.editor = os.getenv('EDITOR')
      self.tmpNote = None

      self.commands = dict()
      self.commands['add'] = self.newNote
      self.commands['search'] = self.search
      self.commands['todo'] = self.newTodo
      self.commands['backup'] = self.backup
      self.commands['contact'] = self.newContact
      self.commands['showDone'] = self.showDone
      self.commands['showUndone'] = self.showUndone
      self.commands['delete'] = self.delete

      self.parseOpts()

      # These are undocumented shortcuts
      self.commands['a'] = self.newNote
      self.commands['s'] = self.search
      self.commands['t'] = self.newTodo
      self.commands['b'] = self.backup
      self.commands['c'] = self.newContact
      self.commands['d'] = self.showDone
      self.commands['u'] = self.showUndone
      self.commands['D'] = self.delete

      try:
         self.commands[self.command](self.commandArgs)
      except KeyError:
         print "{0} does not exist".format(self.command)
         sys.exit(0)

   def delete(self, ID):
      ID = int(ID[0])
      client = MongoClient()
      noteDB = client['note']

      # Find document with ID
      colls = ['notes', 'todo', 'contacts']
      for coll in colls:
         noteDB[coll].remove({"ID": ID})

      unusedIDs = noteDB['IDs'].find_one({"unusedIDs": {"$exists": True}})['unusedIDs']
      unusedIDs.append(ID)
      noteDB['IDs'].update({"unusedIDs": {"$exists": True}}, {"unusedIDs": unusedIDs})

      return

   def search(self, term, resultLimit=50):
      client = MongoClient()
      noteDB = client['note']

      projection = {"ID": 1, "noteText": 1, "timestamp": 1, "_id": 0}
      searchResults = noteDB.command("text", "notes", search=term[0], project=projection, limit=resultLimit)

      results = []
      for result in searchResults['results']:
         noteText = result['obj']['noteText']
         ID = int(result['obj']['ID'])
         timestamp = time.localtime(result['obj']['timestamp'])
         noteDate = time.strftime("%a, %b %d", timestamp)
         results.append( "{5}{6} {4}{2}{0}:{3} {1}".format(noteDate, noteText, FRED, RS, HC, FBLE, ID))

      self.printResults(results)

      return

   def showDone(self, null=None):
      client = MongoClient()
      noteDB = client['note']
      #projection = {"todo": 1, "done": 1, "_id": 0}
      searchResults = noteDB['todo'].find({"done": True})

      results = []
      for result in searchResults:
         text = result['todo']
         timestamp = time.localtime(result['timestamp'])
         date = time.strftime("%a, %b %d", timestamp)
         results.append( "{4}{2}{0}:{3} {1}".format(date, text, FRED, RS, HC))

      self.printResults(results)

      return

   def showUndone(self, null=None):
      client = MongoClient()
      noteDB = client['note']
      #projection = {"todo": 1, "done": 1, "_id": 0}
      searchResults = noteDB['todo'].find({"done": False})

      results = []
      for result in searchResults:
         text = result['todo']
         timestamp = time.localtime(result['timestamp'])
         date = time.strftime("%a, %b %d", timestamp)
         results.append( "{4}{2}{0}:{3} {1}".format(date, text, FRED, RS, HC))

      self.printResults(results)

      return

   def printResults(self, results):
      # Not sure if I want this in a pager or not
      pager = False
      if pager:
         try:
            import pydoc
            pydoc.pager('\n'.join(results))
         except ImportError:
            print '\n'.join(results)
      else:
         print '\n'.join(results)

      return

   def newTodo(self, null=None):
      self.tmpNote = os.path.join(self.homeDir, '.todo.TMP')
      self.tmpTodo = os.path.join(self.homeDir, '.todoTemplate')
      shutil.copyfile(self.tmpTodo, self.tmpNote)
      self.startEditor(2)
      self.processTodo()
      self.addTodoToDB()

   def processTodo(self):
      try:
         with open(self.tmpNote) as fd:
            lines = fd.read()
      except IOError:
         print("Config file doesn't exist, exiting")
         sys.exit(-1)

      todoText = lines[lines.index('TODO') + 4: lines.index('DONE')]
      todoText = todoText.split('\n')
      todoText = filter(lambda x: x != '', todoText)
      todoText = map(lambda x: x.rstrip(), todoText)
      todoText = '\n'.join(todoText)
      self.todoText = todoText

      done = lines[lines.index('DONE') + 4: lines.index('DATE')]
      doneText = done.split('\n')
      doneText = filter(lambda x: x != '', doneText)
      doneText = map(lambda x: x.rstrip(), doneText)
      doneText = '\n'.join(doneText)
      doneText = doneText.lower()
      if ('t' in doneText or 'true' in doneText) and ('f' not in doneText or 'false' not in doneText):
         self.done = True
      else:
         self.done = False

      date = lines[lines.index('DATE') + 4: -1]
      date = date.strip()
      self.date = date

      return

   def addTodoToDB(self):
      client = MongoClient()
      db = client['note']
      collection = db['todo']

      post = {"todo": self.todoText,
              "done": self.done,
              "timestamp": time.time()}
      collection.insert(post)

      return

   def null(self):
      return

   def initDB(self):
      client = MongoClient()
      adminDB = client['admin']
      textSearchEnabled = adminDB.command({"getParameter": 1, "textSearchEnabled": 1})['textSearchEnabled']

      if not textSearchEnabled:
         adminDB.command({"setParameter": 1, "textSearchEnabled": "true"})

      noteDB = client['note']
      if 'notes' not in noteDB.collection_names():
         noteDB.notes.create_index([("noteText", "text"), ("tags", "text")], weights={"tags": 10, "noteText": 5})

      noteDB['IDs'].insert({"currentMax": 0})
      noteDB['IDs'].insert({"unusedIDs": []})

   def newNote(self, null=""):
      self.tmpNote = os.path.join(self.homeDir, '.note.TMP')
      shutil.copyfile(self.templateNote, self.tmpNote)
      self.startEditor(3)
      self.processNote()
      self.addNoteToDB()

      return

   def processNote(self):

      try:
         with open(self.tmpNote) as fd:
            lines = fd.read()
      except IOError:
         print("Config file doesn't exist, exiting")
         sys.exit(-1)

      noteText = lines[lines.index('NOTE') + 4: lines.index('TAGS')]
      noteText = noteText.split('\n')
      noteText = filter(lambda x: x != '', noteText)
      noteText = map(lambda x: x.rstrip(), noteText)
      noteText = '\n'.join(noteText)
      self.noteText = noteText

      tags = lines[lines.index('TAGS') + 4: -1]
      tags = tags.split(',')
      tags = filter(lambda x: x != '', tags)
      tags = map(lambda x: x.rstrip(), tags)
      tags = map(lambda x: x.lstrip(), tags)
      self.tags = tags

      return

   def addNoteToDB(self):
      client = MongoClient()
      db = client['note']
      collection = db['notes']

      post = {"noteText": self.noteText,
              "tags": self.tags,
              "timestamp": time.time(),
              "ID": self.getID()}

      collection.insert(post)

   def newContact(self, null=None):
      self.tmpNote = os.path.join(self.homeDir, '.contact.TMP')
      shutil.copyfile(self.templateContact, self.tmpNote)
      self.startEditor(2)
      self.processContact()
      self.addContactToDB()

      return

   def processContact(self):

      with open(self.tmpNote) as fd:
         contactText = fd.read(8192)

      contactInfo = {}
      idx = []
      lines = contactText.split('\n')
      for i in range(len(lines)):
         if lines[i].isupper():
            idx.append(i)

      for i in range(len(idx)):
         start = idx[i] + 1
         try:
            end = idx[i + 1]
         except:
            end = len(lines) - 1
         key = lines[idx[i]].lower()
         info = lines[start:end]
         info = [x for x in info if x != '']
         if info:
            contactInfo[key] = '\n'.join(info)

      self.contactInfo = contactInfo

      return

   def getID(self):
      client = MongoClient()
      db = client['note']

      unusedIDs = db['IDs'].find_one({"unusedIDs": {"$exists": True}})['unusedIDs']
      if not unusedIDs:
         ID = db['IDs'].find_one({"currentMax": {"$exists": True}})['currentMax'] + 1
         db['IDs'].update({"currentMax": ID - 1}, {"currentMax": ID})
      else:
         unusedIDs = db['IDs'].find_one({"unusedIDs": {"$exists": True}})['unusedIDs']
         ID = min(unusedIDs)
         unusedIDs.remove(ID)
         db['IDs'].update({"unusedIDs": {"$exists": True}},
                          {"$set": {"unusedIDs": unusedIDs}})

      return ID

   def addContactToDB(self):
      client = MongoClient()
      db = client['note']
      collection = db['contacts']

      ID = self.getID()

      post = {"contact": self.contactInfo,
              "timestamp": time.time(),
              "ID": ID}

      collection.insert(post)

      return

   def startEditor(self, startingLine=1):
      if self.editor == "/usr/bin/vim" or self.editor == '/usr/local/bin/vim':
         subprocess.call([self.editor, "+{0}".format(startingLine),
                          "-c", "startinsert", self.tmpNote])
      else:
         subprocess.call([self.editor, self.tmpNote])

   def parseOpts(self):
      parser = argparse.ArgumentParser(description="note")

      defaultConfigPath = os.path.expanduser('~/.note.json')
      parser.add_argument('--configFile', type=str, help='Path to config file',
                          default=defaultConfigPath)

      commandHelp = 'note: eligible commands are: {0}'.format(', '.join(self.commands.keys()))
      parser.add_argument('command', metavar='cmd', type=str, nargs='+',
                          help=commandHelp)

      args = parser.parse_args()

      self.configFile = args.configFile
      self.command = args.command[0]

      self.commandArgs = args.command[1:]

      return

   def backup(self, dst):

      self.initGPG()

      return

   def encrypt(self):

      return

   def initGPG(self):
      try:
         self.gpg = gnupg.GPG()
      except NameError:
         self.gpg = None
         return

      private_keys = self.gpg.list_keys(True)
      usable_keys = []
      for key in private_keys:
         if time.time() < key['expires']:
            usable_keys.append(key)

      print "Select key:"
      counter = 1
      for key in usable_keys:
         print "[{0}] Fingerprint: {1}, Key Length: {2}, UIDs: {3}".format(counter, key['fingerprint'], key['length'], key['uids'])
         counter = counter + 1

      data = int(sys.stdin.readline())

      self.key = usable_keys[data - 1]

      return


if __name__ == '__main__':
   main()
