#!/usr/bin/env python

__author__ = "Devin Kelly"
__email__ = "dwwkelly@gmail.com"
__version__ = 0.1
__todo__ = '''
-add ability to edit note/todo/contact
-add support for mongolab backups
-add support for dropbox/box backups
-test todo system
-add ability to change todo state
-make install command that copies template files to home
-import contacts from google - https://developers.google.com/google-apps/contacts/v3/
-add a verify command that checks IDs collection against other collections for consistency
-switch to a SQL database?
-possibly rewrite code to take utilize inheritance
-when editing a note, should the timestamp be the original, the newest or a list of all edits?
-make a note info command which shows note, tags and all other metadata
'''

__added_features__ = '''
-add ability to delete note/todo/contact
-add system for handling contact (email, phone, address, etc)
-complete encrpytion implementation
-fine tune search
'''

import subprocess
import argparse
import os
import sys
import time
import copy
import subprocess as SP
from pymongo import MongoClient
from abc import ABCMeta, abstractmethod

try:
   import gnupg
except ImportError:
   pass

try:
   import dropbox
except ImportError:
   pass


RS = "\033[0m"     # reset
HC = "\033[1m"     # hicolor
UL = "\033[4m"     # underline
INV = "\033[7m"    # invert foreground and background
FBLK = "\033[30m"
FRED = "\033[31m"
FGRN = "\033[32m"
FYEL = "\033[33m"
FBLE = "\033[34m"
FMAG = "\033[35m"
FCYN = "\033[36m"
FWHT = "\033[37m"
BBLK = "\033[40m"
BRED = "\033[41m"
BGRN = "\033[42m"
BYEL = "\033[43m"
BBLE = "\033[44m"
BMAG = "\033[45m"
BCYN = "\033[46m"
BWHT = "\033[47m"


def main():

   runner = Runner()
   runner.null()


class dbBaseClass:
   __metaclass__ = ABCMeta

   @abstractmethod
   def addItem(self, itemType, itemContents):
      pass

   @abstractmethod
   def getItem(self, itemID):
      pass

   @abstractmethod
   def searchForItem(self, searchInfo):
      pass

   @abstractmethod
   def deleteItem(self, itemID):
      pass

   @abstractmethod
   def getBackup(self):
      pass


class mongoDB(dbBaseClass):

   def __init__(self, dbName):
      """

      """
      self.dbName = dbName

      self.client = MongoClient()
      adminDB = self.client['admin']
      textSearchEnabled = adminDB.command({"getParameter": 1, "textSearchEnabled": 1})['textSearchEnabled']

      if not textSearchEnabled:
         adminDB.command({"setParameter": 1, "textSearchEnabled": "true"})

      self.noteDB = self.client[self.dbName]
      if 'notes' not in self.noteDB.collection_names():
         self.noteDB.notes.create_index([("noteText", "text"), ("tags", "text")], weights={"tags": 10, "noteText": 5})

      if self.noteDB.IDs.find({"currentMax": {"$exists": True}}).count() == 0:
         self.noteDB['IDs'].insert({"currentMax": 0})

      if self.noteDB.IDs.find({"unusedIDs": {"$exists": True}}).count() == 0:
         self.noteDB['IDs'].insert({"unusedIDs": []})

   def addItem(self, itemType, itemContents, itemID=None):
      """
         itemType really means the collection name or table name
      """
      collection = self.noteDB[itemType]

      if itemID is None:
         itemContents['timestamps'] = [time.time()]
         itemContents["ID"] = self.getNewID()
         collection.insert(itemContents)
      else:
         _id = collection.find_one({"ID": itemID})["_id"]
         timestamps = collection.find_one({"ID": itemID})["timestamps"]
         timestamps.append(time.time())
         itemContents["timestamps"] = timestamps
         itemContents["ID"] = itemID
         collection.update({"_id": _id}, itemContents)

      return

   def getNewID(self):
      """
         Get a new ID by either incrementing the currentMax ID or using an unusedID

      """
      idCollection = self.noteDB['IDs']
      unusedIDs = idCollection.find_one({"unusedIDs": {"$exists": True}})['unusedIDs']

      if not unusedIDs:
         ID = idCollection.find_one({"currentMax": {"$exists": True}})['currentMax'] + 1
         idCollection.update({"currentMax": ID - 1}, {"currentMax": ID})
      else:
         unusedIDs = idCollection.find_one({"unusedIDs": {"$exists": True}})['unusedIDs']
         ID = min(unusedIDs)
         unusedIDs.remove(ID)
         idCollection.update({"unusedIDs": {"$exists": True}},
                             {"$set": {"unusedIDs": unusedIDs}})

      return ID

   def getItem(self, itemID):
      """
         Given an ID return the note JSON object

         {u'noteText': u'note8', u'ID': 3.0, u'tags': [u'8'], u'timestamps': [1381719620.315899]}

      """
      collections = self.noteDB.collection_names()
      collections.remove(u'system.indexes')
      collections.remove(u'IDs')

      for coll in collections:
         note = self.noteDB[coll].find_one({"ID": itemID})
         if note is not None:
            break

      del note["_id"]
      return note

   def getItemType(self, itemID):
      """
         Given an itemID, return the "type" i.e. the collection it belongs to.
      """
      collections = self.noteDB.collection_names()
      collections.remove(u'system.indexes')
      collections.remove(u'IDs')

      for coll in collections:
         note = self.noteDB[coll].find_one({"ID": itemID})
         if note is not None:
            return coll

   def searchForItem(self, searchInfo, resultLimit=20):
      """
      Given a search term returns a list of results that match that term:

         [{u'score': 5.5, u'obj': {u'noteText': u'note8', u'ID': 3.0, u'timestamps': [1381719620.315899]}}]

      """

      # FIXME -- move search to DB class
      #projection = {"ID": 1, "noteText": 1, "timestamps": 1, "_id": 0}
      #searchResults = self.noteDB.command("text", "notes", search=searchInfo, project=projection, limit=resultLimit)

      searchResults = []

      colls = self.db.collection_names()
      colls.remove(u'system.indexes')
      colls.remove(u'IDs')

      proj = {"_id": 0}
      for coll in colls:
         res = self.noteDB.command("text", coll, search=searchInfo, project=proj, limit=resultLimit)['results']
         searchResults.extend(res)

      return searchResults

   def deleteItem(self, itemID):
      """
         Deletes item with ID = itemID, takes care of IDs collection
      """
      collections = self.noteDB.collection_names()
      collections.remove(u'system.indexes')
      collections.remove(u'IDs')

      currentMax = self.noteDB["IDs"].find_one({"currentMax": {"$exists": True}})['currentMax']
      unusedIDs = self.noteDB['IDs'].find_one({"unusedIDs": {"$exists": True}})['unusedIDs']

      if (itemID > currentMax) or (itemID in unusedIDs):
         print("Item {0} does not exist".format(itemID))
         sys.exit(1)

      # Find document with ID
      for coll in collections:
         self.noteDB[coll].remove({"ID": itemID})

      if currentMax == itemID:
         self.noteDB['IDs'].update({"currentMax": currentMax}, {"currentMax": currentMax - 1})
      else:
         unusedIDs.append(itemID)
         self.noteDB['IDs'].update({"unusedIDs": {"$exists": True}}, {"unusedIDs": unusedIDs})

   def getBackup(self):

      return


def sqliteDB(dbBaseClass):

   def __init__(self):

      return

   def addItem(self, itemType, itemContents):

      return

   def getItem(self, itemID):

      return

   def searchForItem(self, searchInfo):

      return

   def deleteItem(self, itemID):

      return

   def getBackup(self):

      return


class NoteBaseClass(object):
   __metaclass__ = ABCMeta

   """ Virtual Methods """

   @abstractmethod
   def __init__(self, db):
      self.homeDir = os.path.expanduser('~')
      self.tmpNote = os.path.join(self.homeDir, '.note.TMP')
      self.editor = os.getenv('EDITOR')
      self.db = db
      return

   @abstractmethod
   def edit(self, ID):
      return

   @abstractmethod
   def new(self):
      return

   @abstractmethod
   def search(self, searchTerm):
      return

   """ Concrete Methods """

   def delete(self, ID):
      """

      """
      try:
         ID = int(ID[0])
      except TypeError:
         pass

      self.db.deleteItem(ID)
      return

   def startEditor(self, startingLine=1):
      if self.editor == "/usr/bin/vim" or self.editor == '/usr/local/bin/vim':
         subprocess.call([self.editor, "+{0}".format(startingLine),
                          "-c", "startinsert", self.tmpNote])
      else:
         subprocess.call([self.editor, self.tmpNote])

   def printResults(self, results):
      # Not sure if I want this in a pager or not
      pager = False
      if pager:
         try:
            import pydoc
            pydoc.pager('\n'.join(results))
         except ImportError:
            print '\n'.join(results)
      else:
         print '\n'.join(results)

      return


class Note(NoteBaseClass):
   def __init__(self, db):
      """

      """
      super(Note, self).__init__(db)
      self.noteType = "notes"
      self.noteTemplate = "NOTE\n\n\n\nTAGS\n\n\n"
      self.noteEditTemplate = "NOTE\n\n{0}\n\nTAGS\n\n{1}\n"

   def processNote(self):

      try:
         with open(self.tmpNote) as fd:
            lines = fd.read()
      except IOError:
         print("Config file doesn't exist, exiting")
         sys.exit(-1)

      noteText = lines[lines.index('NOTE') + 4: lines.index('TAGS')]
      noteText = noteText.split('\n')
      noteText = filter(lambda x: x != '', noteText)
      noteText = map(lambda x: x.rstrip(), noteText)
      noteText = '\n'.join(noteText)
      self.noteText = noteText

      tags = lines[lines.index('TAGS') + 4: -1]
      tags = tags.split(',')
      tags = filter(lambda x: x != '', tags)
      tags = map(lambda x: x.rstrip(), tags)
      tags = map(lambda x: x.lstrip(), tags)
      self.tags = tags

   def edit(self, ID):
      """

      """
      ID = int(ID[0])
      origNote = self.db.getItem(ID)
      origNotetext = origNote['noteText']
      origTags = ','.join(origNote['tags'])

      editText = self.noteEditTemplate.format(origNotetext, origTags)
      self.tmpNote = os.path.join(self.homeDir, '.note.TMP')
      with open(self.tmpNote, 'w') as fd:
         fd.write(editText)

      self.startEditor(3)
      self.processNote()
      self.db.addItem(self.noteType, {"noteText": self.noteText, "tags": self.tags}, ID)

   def new(self, dummy=None):
      """

      """

      with open(self.tmpNote, 'w') as fd:
         fd.write(self.noteTemplate)
      self.startEditor(3)
      self.processNote()

      self.db.addItem("notes", {"noteText": self.noteText, "tags": self.tags})

      return

   def search(self, searchTerm, resultLimit=20):
      """

      """
      results = []
      searchResults = self.db.searchForItem(searchTerm[0], resultLimit)
      for result in searchResults:
         noteText = result['obj']['noteText']
         ID = int(result['obj']['ID'])
         timestamps = result['obj']['timestamps']
         timestamp = time.localtime(max(timestamps))
         noteDate = time.strftime("%a, %b %d", timestamp)
         results.append( "{5}{6} {4}{2}{0}:{3} {1}".format(noteDate, noteText, FRED, RS, HC, FBLE, ID))

      self.printResults(results)


class ToDo(NoteBaseClass):

   def __init__(self, db):
      super(ToDo, self).__init__(db)
      self.noteType = "todos"
      self.todoTemplate = "TODO\n\n\n\nDONE\n\n\n\nDATE - MM DD YY\n\n\n"
      self.todoEditTemplate = "TODO\n\n{0}\n\nDONE\n\n{1}\n\nDATE - MM DD YY\n\n\n"

   def edit(self, ID):
      return

   def new(self, dummy=None):
      self.tmpNote = os.path.join(self.homeDir, '.todo.TMP')
      with open(self.tmpNote, 'w') as fd:
         fd.write(self.todoTemplate)
      self.startEditor(2)
      self.processTodo()
      self.db.addItem(self.noteType, {"todoText": self.todoText, "done": self.done, "date": self.date})
      return

   def processTodo(self):
      try:
         with open(self.tmpNote) as fd:
            lines = fd.read()
      except IOError:
         print("Config file doesn't exist, exiting")
         sys.exit(-1)

      todoText = lines[lines.index('TODO') + 4: lines.index('DONE')]
      todoText = todoText.split('\n')
      todoText = filter(lambda x: x != '', todoText)
      todoText = map(lambda x: x.rstrip(), todoText)
      todoText = '\n'.join(todoText)
      self.todoText = todoText

      done = lines[lines.index('DONE') + 4: lines.index('DATE - MM DD YY')]
      doneText = done.split('\n')
      doneText = filter(lambda x: x != '', doneText)
      doneText = map(lambda x: x.rstrip(), doneText)
      doneText = '\n'.join(doneText)
      doneText = doneText.lower()
      if ('t' in doneText or 'true' in doneText or 'yes' in doneText) and \
         ('f' not in doneText or 'false' not in doneText or 'no' not in doneText):
         self.done = True
      else:
         self.done = False

      date = lines[lines.index('DATE - MM DD YY') + 15: -1]
      date = date.strip()
      self.date = date

   def search(self, searchTerm):

      return

   def showDone(self, dummy=None):
      return

   def showUndone(self, dummy=None):
      return


class Contact(NoteBaseClass):

   def __init__(self, db):
      super(Contact, self).__init__(db)
      self.noteType = "contacts"
      self.contactTemplate = "NAME\n\n\n\nAFFILIATION\n\n\n\nEMAIL\n\n\n\nMOBILE PHONE\n\n\n\nHOME PHONE\n\n\n\nWORK PHONE\n\n\n\nADDRESS\n\n\n"
      self.contactEditTemplate = "NAME\n\n{0}\n\nAFFILIATION\n\n{1}\n\nEMAIL\n\n{2}\n\nMOBILE PHONE\n\n{3}\n\nHOME PHONE\n\n{4}\n\nWORK PHONE\n\n{5}\n\nADDRESS\n\n\n"
      self.keys = ["NAME", "AFFILIATION", "EMAIL", "MOBILE PHONE", "HOME PHONE", "WORK PHONE", "ADDRESS"]
      self.tmpNote = os.path.join(self.homeDir, '.contact.TMP')
      self.contactInfo = {}

   def edit(self, ID):

      ID = int(ID[0])
      origContact = self.db.getItem(ID)
      self.contactEditTemplate

      editText = self.contactEditTemplate.format(origContact['NAME'],
                                                 origContact['AFFILIATION'],
                                                 origContact['EMAIL'],
                                                 origContact['MOBILE PHONE'],
                                                 origContact['HOME PHONE'],
                                                 origContact['WORK PHONE'],
                                                 origContact['ADDRESS'])

      with open(self.tmpNote, 'w') as fd:
         fd.write(editText)

      self.startEditor(3)
      self.processContact()
      self.db.addItem(self.noteType, self.contactInfo, ID)
      return

   def new(self, dummy=None):
      with open(self.tmpNote, 'w') as fd:
         fd.write(self.contactTemplate)
      self.startEditor(3)
      self.processContact()
      self.db.addItem("contacts", self.contactInfo)

   def processContact(self):
      try:
         with open(self.tmpNote) as fd:
            lines = fd.read()
      except IOError:
         print("Config file doesn't exist, exiting")
         sys.exit(-1)

      keys = copy.deepcopy(self.keys)
      keys.reverse()

      for k in keys:
         self.contactInfo[k] = (lines.split(k)[-1]).strip()
         lines = " ".join(lines.split(k)[0:-1])

   def search(self, searchTerm):
      return


class Runner(object):

   def __init__(self):

      self.dbName = 'note'
      db = mongoDB(self.dbName)

      # TODO - when editing or deleting get the ID number then
      # initialize the object ie if the ID is for a todo
      # then get the ID, figure out that it belongs to a todo
      # then make
      # self.commands['delete'] = todo.delete

      self.commands = ['backup', 'showUndone', 'showDone', 'todo', 'contact', 'edit', 'delete', 'search', 'add']
      note = Note(db)
      todo = ToDo(db)
      contact = Contact(db)
      itemTypes = {"notes": note, "todos": todo, "contacts": contact}

      self.commands = dict()
      self.commands['add'] = note.new
      self.commands['search'] = note.search
      self.commands['delete'] = note.delete
      self.commands['edit'] = note.edit

      self.commands['contact'] = contact.new
      self.commands['todo'] = todo.new
      self.commands['showDone'] = todo.showDone
      self.commands['showUndone'] = todo.showUndone
      self.commands['backup'] = self.backup

      self.parseOpts()

      if self.command in ['edit', 'delete', 'e', 'D']:
         itemType = db.getItemType(int(self.commandArgs[0]))
         self.commands['delete'] = itemTypes[itemType].delete
         self.commands['edit'] = itemTypes[itemType].edit

      # These are undocumented shortcuts
      self.commands['a'] = self.commands['add']
      self.commands['s'] = self.commands['search']
      self.commands['D'] = self.commands['delete']
      self.commands['e'] = self.commands['edit']

      self.commands['t'] = self.commands['todo']
      self.commands['d'] = self.commands['showDone']
      self.commands['u'] = self.commands['showUndone']
      self.commands['c'] = self.commands['contact']
      self.commands['b'] = self.commands['backup']

      try:
         self.commands[self.command](self.commandArgs)
      except KeyError:
         print "{0} does not exist".format(self.command)
         sys.exit(0)

   def null(self):
      return

   def parseOpts(self):
      parser = argparse.ArgumentParser(description="note")

      defaultConfigPath = os.path.expanduser('~/.note.json')
      parser.add_argument('--configFile', type=str, help='Path to config file',
                          default=defaultConfigPath)

      commandHelp = 'note: eligible commands are: {0}'.format(', '.join(self.commands))
      parser.add_argument('command', metavar='cmd', type=str, nargs='+',
                          help=commandHelp)

      args = parser.parse_args()

      self.configFile = args.configFile
      self.command = args.command[0]

      self.commandArgs = args.command[1:]

      return

   def backup(self, dst):

      self.initGPG()

      if not dst:
         dst = '/tmp'
      else:
         dst = dst[0]

      backupZip = os.path.join(dst, 'note_backup.zip')
      backupGPG = os.path.join(dst, 'note_backup.gpg')

      with open(os.devnull) as devnull:
         SP.call(['mongodump', '--db', self.dbName, '--out', dst], stdout=devnull, stderr=devnull)
         SP.call(['zip', '-r', os.path.join(dst, backupZip), os.path.join(dst, self.dbName)], stdout=devnull, stderr=devnull)

      if self.key is not None:
         stream = open(backupZip, "rb")
         self.gpg.encrypt_file(stream, [self.key['fingerprint']], output=backupGPG)
         SP.call(['rm', '-rf', os.path.join(dst, 'note_backup.zip')])
         print "Encrypted Backup: {0}".format(backupGPG)
      else:
         print "Backup: {0}".format(backupZip)

      SP.call(['rm', '-rf', os.path.join(dst, self.dbName)])

      return

   def encrypt(self):

      return

   def initGPG(self):
      try:
         self.gpg = gnupg.GPG()
      except NameError:
         self.gpg = None
         self.key = None
         return

      private_keys = self.gpg.list_keys(True)
      usable_keys = []
      for key in private_keys:
         if time.time() < key['expires']:
            usable_keys.append(key)

      print "Select key:"
      counter = 0
      for key in usable_keys:
         print "[{0}] Fingerprint: {1}, Key Length: {2}, UIDs: {3}".format(counter, key['fingerprint'], key['length'], key['uids'])
         counter = counter + 1

      data = int(sys.stdin.readline())

      if data == 0:
         self.key = None
      else:
         self.key = usable_keys[data - 1]

      return

   def pushToDropbox(self):

      app_key = ''
      app_secret = ''
      code = ""

      flow = dropbox.client.DropboxOAuth2FlowNoRedirect(app_key, app_secret)

      access_token, user_id = flow.finish(code)
      client = dropbox.client.DropboxClient(access_token)

      f = open(self.mongoBackup)
      response = client.put_file('/note-backup.gpg', f)
      print "uploaded:", response


if __name__ == '__main__':
   main()
